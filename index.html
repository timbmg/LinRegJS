<style>
body {
  padding: 0;
  margin: 0;
}
.container {
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
}

.subcontainer {
  width: 500px;
  height: 550px;
  position: relative;
}

.canvas {
  width: 500px;
  height: 500px;
  position: absolute;
}

.output {
  width: 500px;
  height: 50px;
  position: absolute;
  bottom: 0;
}

#canvas-coordsystem {
  z-index: 0;
  background-color: #F0F0F0;
  /* border: 1px solid; */
}
#canvas-line {
  z-index: 1;
}


</style>

<div class='container'>

  <div class='subcontainer'>
    <canvas class="canvas" id="canvas-coordsystem" width="500px" height="500px"></canvas>
    <canvas class="canvas" id="canvas-line" width="500px" height="500px"></canvas>
    <div class="output" id="output"></div>
</div>
</div>

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script>

const canvasCoord = document.getElementById('canvas-coordsystem');
const ctxCoord = canvasCoord.getContext("2d");

ctxCoord.strokeStyle = "#11111";
// X Axis
ctxCoord.beginPath();
ctxCoord.moveTo(0, 250);
ctxCoord.lineTo(500, 250);
ctxCoord.stroke();
// Y Axis
ctxCoord.beginPath();
ctxCoord.moveTo(250, 0);
ctxCoord.lineTo(250, 500);
ctxCoord.stroke();

const canvasLine = document.getElementById('canvas-line');
const ctxLine = canvasLine.getContext("2d");

const output = document.getElementById('output');

const XY = [];
var m = 0;
var b = 0;


canvasLine.addEventListener('click', function(event) {
  // adds a point to the coordinate canvas where user has clicked
  const {offsetX,offsetY} = event;
  console.log(offsetX, offsetY);

  ctxCoord.fillStyle = "#4B77BE";
  ctxCoord.beginPath();
  ctxCoord.arc(offsetX, offsetY, 3, 0, 2*Math.PI);
  ctxCoord.fill();

  const pointCords = {
    x : screenToCartesian(offsetX, offsetY)[0],
    y : screenToCartesian(offsetX, offsetY)[1]
  }

  XY.push(pointCords);
  resetParameters();

});

document.addEventListener('keypress', function (e) {
    var key = e.which || e.keyCode;
    if (key === 13) { // 13 is enter
      console.log(XY);
      // start algorithm
      resetParameters();
      gradientDescent();
    }
});

function meanSquaredError() {
  // calculate the mean squared error of current solution
  var loss = 0;
  const N = XY.length;

  for (var i=0; i<N; i++) {
    loss += (XY[i].y - (m * XY[i].x + b)) ** 2;
  }
  loss = loss / N;

  return loss;
}

function backward() {
  // calcualte the gradients of m and b
  var dm = 0;
  var db = 0;
  const N = XY.length;

  for (var i=0; i<N; i++) {
      y_hat = (m * XY[i].x + b)
      dm += -(2/N) * XY[i].x * (XY[i].y - y_hat);
      db += -(2/N) * (XY[i].y - y_hat);
  }

  const gradients = {
    m: dm,
    b: db
  }

  return gradients;

}

function resetParameters() {
  m = 0;
  b = 0;
}

async function gradientDescent() {

  const alpha = 0.00005; // learning rate for m
  const beta = 0.1; // learning rate for b

  var previousLoss = 0;

  while (true) {

    loss = meanSquaredError();
    gradients = backward()

    // update m and b
    m = m - alpha * gradients.m;
    b = b - beta * gradients.b;

    console.log(loss);

    updateLine();

    await sleep(25);

    // check convergence
    if (Math.abs(loss - previousLoss) < 0.01) {
      break;
    }
    previousLoss = loss;
  }

  // print formula
  outputSolution();
}

function updateLine() {
  // draws a line with current parameters m and b
  var startXY = cartesianToScreen(-250, m * -250 + b);
  var finalXY = cartesianToScreen(250, m * 250 + b);

  ctxLine.strokeStyle = "#C91F37";
  ctxLine.beginPath();
  ctxLine.moveTo(startXY[0], startXY[1]);
  ctxLine.lineTo(finalXY[0], finalXY[1]);
  ctxLine.clearRect(0, 0, canvasLine.width, canvasLine.height);
  ctxLine.stroke();
}

function outputSolution() {
  // outputs solution formula in mathjax
  output.innerHTML = "$f(x) = " + m.toFixed(3).toString() + " * x + " + b.toFixed(3).toString() + "$";
  MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
}

function cartesianToScreen(x, y) {
  // convert cartesian coordinates to screen coordinates
  x = x > 0 ? x+250 : x+250;
  y = y > 0 ? 250-y : 250-y;

  return [x, y];
}

function screenToCartesian(x, y) {
  // convert cartesian screen coordinates to cartesian coordinates
  x = x  >= 250 ? (x-250) : -(250-x);
  y = y  >= 250 ? -(y-250) : (250-y);

  return [x, y]
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

</script>
